# 后端工作流引擎详细规划

## 1. 整体架构

### 1.1 技术栈
- **运行时引擎**: 自研状态机引擎
- **条件求值**: Handlebars 模板引擎
- **任务队列**: Bull (基于 Redis)
- **数据库**: Prisma + PostgreSQL
- **事件总线**: EventEmitter2
- **日志记录**: Winston

### 1.2 核心模块

```
apps/server/src/modules/workflow-engine/
├── workflow-engine.module.ts          # 模块定义
├── services/
│   ├── workflow-executor.service.ts   # 工作流执行器
│   ├── task-manager.service.ts        # 任务管理器
│   ├── condition-evaluator.service.ts # 条件求值器
│   └── state-machine.service.ts       # 状态机引擎
├── controllers/
│   ├── workflow-instance.controller.ts # 实例管理
│   └── task.controller.ts             # 任务操作
├── entities/
│   ├── workflow-context.ts            # 执行上下文
│   └── workflow-token.ts              # 流转令牌
├── processors/
│   ├── node-processor.interface.ts    # 节点处理器接口
│   ├── user-task.processor.ts         # 用户任务处理器
│   ├── service-task.processor.ts      # 服务任务处理器
│   ├── gateway.processor.ts           # 网关处理器
│   └── parallel-gateway.processor.ts  # 并行网关处理器
├── events/
│   ├── workflow.events.ts             # 工作流事件
│   └── task.events.ts                 # 任务事件
└── utils/
    ├── expression-parser.ts           # 表达式解析器
    └── workflow-validator.ts          # DSL 验证器
```

---

## 2. 数据模型设计

### 2.1 Prisma Schema 扩展

```prisma
// 工作流定义（已存在）
model Workflow {
  id          String   @id @default(cuid())
  tenantId    String
  name        String
  description String?
  dsl         Json     // WorkflowDSL
  version     String   @default("1.0.0")
  status      String   @default("draft") // draft | active | archived
  createdBy   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  instances   WorkflowInstance[]
  
  @@index([tenantId, status])
  @@map("workflows")
}

// 工作流实例
model WorkflowInstance {
  id             String    @id @default(cuid())
  workflowId     String
  tenantId       String
  status         String    // running | suspended | completed | error | cancelled
  currentNodeIds String[]  // 当前活跃节点（支持并行）
  variables      Json      // 流程变量
  context        Json?     // 执行上下文
  initiator      String    // 发起人
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  completedAt    DateTime?
  errorMessage   String?
  
  workflow       Workflow @relation(fields: [workflowId], references: [id])
  tasks          TaskInstance[]
  tokens         WorkflowToken[]
  logs           WorkflowLog[]
  
  @@index([tenantId, status])
  @@index([workflowId, status])
  @@map("workflow_instances")
}

// 任务实例
model TaskInstance {
  id           String    @id @default(cuid())
  instanceId   String
  nodeId       String    // 对应 DSL 中的节点 ID
  nodeName     String    // 节点名称
  nodeType     String    // UserTask | ServiceTask
  assignee     String?   // 审批人
  status       String    // pending | in_progress | completed | rejected | cancelled
  formData     Json?     // 表单数据
  dueDate      DateTime? // 超时时间
  createdAt    DateTime  @default(now())
  completedAt  DateTime?
  completedBy  String?
  comment      String?   // 审批意见
  
  instance     WorkflowInstance @relation(fields: [instanceId], references: [id])
  
  @@index([assignee, status])
  @@index([instanceId, status])
  @@map("task_instances")
}

// 工作流令牌（用于并行流转）
model WorkflowToken {
  id           String   @id @default(cuid())
  instanceId   String
  nodeId       String   // 当前所在节点
  parentTokenId String? // 父令牌（并行分支）
  status       String   // active | completed | merged
  createdAt    DateTime @default(now())
  completedAt  DateTime?
  
  instance     WorkflowInstance @relation(fields: [instanceId], references: [id])
  
  @@index([instanceId, status])
  @@map("workflow_tokens")
}

// 工作流日志
model WorkflowLog {
  id         String   @id @default(cuid())
  instanceId String
  level      String   // info | warn | error
  message    String
  nodeId     String?
  taskId     String?
  metadata   Json?
  createdAt  DateTime @default(now())
  
  instance   WorkflowInstance @relation(fields: [instanceId], references: [id])
  
  @@index([instanceId, createdAt])
  @@map("workflow_logs")
}
```

---

## 3. 核心服务实现

### 3.1 工作流执行器（WorkflowExecutor）

```typescript
@Injectable()
export class WorkflowExecutorService {
  constructor(
    private prisma: PrismaService,
    private stateMachine: StateMachineService,
    private taskManager: TaskManagerService,
    private eventBus: EventEmitter2,
  ) {}

  /**
   * 启动工作流
   */
  async startWorkflow(
    workflowId: string,
    variables: Record<string, any>,
    initiator: string,
    tenantId: string,
  ): Promise<WorkflowInstance> {
    // 1. 加载工作流定义
    const workflow = await this.prisma.workflow.findUnique({
      where: { id: workflowId },
    });

    if (!workflow || workflow.status !== 'active') {
      throw new Error('工作流不存在或未激活');
    }

    const dsl = workflow.dsl as WorkflowDSL;

    // 2. 验证 DSL
    this.validateWorkflowDSL(dsl);

    // 3. 创建工作流实例
    const instance = await this.prisma.workflowInstance.create({
      data: {
        workflowId,
        tenantId,
        status: 'running',
        currentNodeIds: [],
        variables,
        initiator,
        context: {
          startTime: new Date().toISOString(),
          nodeExecutionCount: {},
        },
      },
    });

    // 4. 创建初始令牌
    const startNode = dsl.nodes.find((n) => n.type === 'StartEvent');
    if (!startNode) {
      throw new Error('找不到开始节点');
    }

    await this.createToken(instance.id, startNode.id);

    // 5. 发送启动事件
    this.eventBus.emit('workflow.started', { instanceId: instance.id });

    // 6. 执行开始节点
    await this.executeNode(instance.id, startNode.id);

    return instance;
  }

  /**
   * 执行节点
   */
  async executeNode(instanceId: string, nodeId: string): Promise<void> {
    const instance = await this.prisma.workflowInstance.findUnique({
      where: { id: instanceId },
      include: { workflow: true },
    });

    if (!instance) {
      throw new Error('工作流实例不存在');
    }

    const dsl = instance.workflow.dsl as WorkflowDSL;
    const node = dsl.nodes.find((n) => n.id === nodeId);

    if (!node) {
      throw new Error(`节点 ${nodeId} 不存在`);
    }

    // 记录日志
    await this.logWorkflowEvent(instanceId, 'info', `执行节点: ${node.name}`, nodeId);

    // 根据节点类型执行
    switch (node.type) {
      case 'StartEvent':
        await this.executeStartEvent(instance, node, dsl);
        break;
      case 'EndEvent':
        await this.executeEndEvent(instance, node);
        break;
      case 'UserTask':
        await this.executeUserTask(instance, node);
        break;
      case 'ServiceTask':
        await this.executeServiceTask(instance, node);
        break;
      case 'Gateway':
        await this.executeGateway(instance, node, dsl);
        break;
      case 'ParallelGateway':
        await this.executeParallelGateway(instance, node, dsl);
        break;
      default:
        throw new Error(`不支持的节点类型: ${node.type}`);
    }
  }

  /**
   * 执行开始节点
   */
  private async executeStartEvent(
    instance: WorkflowInstance,
    node: WorkflowNode,
    dsl: WorkflowDSL,
  ): Promise<void> {
    // 更新当前节点
    await this.prisma.workflowInstance.update({
      where: { id: instance.id },
      data: { currentNodeIds: [node.id] },
    });

    // 找到下一个节点
    const outgoingEdges = dsl.edges.filter((e) => e.source === node.id);
    if (outgoingEdges.length === 0) {
      throw new Error('开始节点没有出边');
    }

    // 执行下一个节点
    const nextNodeId = outgoingEdges[0].target;
    await this.executeNode(instance.id, nextNodeId);
  }

  /**
   * 执行结束节点
   */
  private async executeEndEvent(
    instance: WorkflowInstance,
    node: WorkflowNode,
  ): Promise<void> {
    // 完成令牌
    await this.completeToken(instance.id, node.id);

    // 检查是否所有令牌都已完成
    const activeTokens = await this.prisma.workflowToken.count({
      where: {
        instanceId: instance.id,
        status: 'active',
      },
    });

    if (activeTokens === 0) {
      // 工作流完成
      await this.prisma.workflowInstance.update({
        where: { id: instance.id },
        data: {
          status: 'completed',
          completedAt: new Date(),
        },
      });

      await this.logWorkflowEvent(instance.id, 'info', '工作流完成');
      this.eventBus.emit('workflow.completed', { instanceId: instance.id });
    }
  }

  /**
   * 执行用户任务
   */
  private async executeUserTask(
    instance: WorkflowInstance,
    node: WorkflowNode,
  ): Promise<void> {
    const config = node.props as UserTaskConfig;

    // 解析审批人（支持模板变量）
    const assignee = this.resolveAssignee(config.assignee, instance.variables);

    // 创建任务实例
    const task = await this.prisma.taskInstance.create({
      data: {
        instanceId: instance.id,
        nodeId: node.id,
        nodeName: node.name || 'UserTask',
        nodeType: 'UserTask',
        assignee,
        status: 'pending',
        dueDate: config.dueDate ? this.parseDueDate(config.dueDate) : null,
      },
    });

    // 更新当前节点
    await this.prisma.workflowInstance.update({
      where: { id: instance.id },
      data: { currentNodeIds: [node.id] },
    });

    await this.logWorkflowEvent(
      instance.id,
      'info',
      `创建用户任务: ${assignee}`,
      node.id,
      task.id,
    );

    this.eventBus.emit('task.created', { taskId: task.id });
  }

  /**
   * 完成用户任务
   */
  async completeUserTask(
    taskId: string,
    formData: Record<string, any>,
    completedBy: string,
    comment?: string,
  ): Promise<void> {
    const task = await this.prisma.taskInstance.findUnique({
      where: { id: taskId },
      include: { instance: { include: { workflow: true } } },
    });

    if (!task) {
      throw new Error('任务不存在');
    }

    if (task.status !== 'pending') {
      throw new Error('任务已处理');
    }

    // 更新任务状态
    await this.prisma.taskInstance.update({
      where: { id: taskId },
      data: {
        status: 'completed',
        formData,
        completedBy,
        completedAt: new Date(),
        comment,
      },
    });

    // 合并表单数据到流程变量
    const updatedVariables = {
      ...task.instance.variables,
      ...formData,
    };

    await this.prisma.workflowInstance.update({
      where: { id: task.instanceId },
      data: { variables: updatedVariables },
    });

    await this.logWorkflowEvent(
      task.instanceId,
      'info',
      `任务完成: ${completedBy}`,
      task.nodeId,
      taskId,
    );

    this.eventBus.emit('task.completed', { taskId });

    // 继续执行下一个节点
    const dsl = task.instance.workflow.dsl as WorkflowDSL;
    const outgoingEdges = dsl.edges.filter((e) => e.source === task.nodeId);

    if (outgoingEdges.length > 0) {
      await this.executeNode(task.instanceId, outgoingEdges[0].target);
    }
  }

  /**
   * 执行服务任务
   */
  private async executeServiceTask(
    instance: WorkflowInstance,
    node: WorkflowNode,
  ): Promise<void> {
    const config = node.props as ServiceTaskConfig;

    try {
      // 根据 action 执行不同的操作
      switch (config.action) {
        case 'sendEmail':
          await this.sendEmail(config.params, instance.variables);
          break;
        case 'callApi':
          await this.callApi(config.params, instance.variables);
          break;
        case 'executeScript':
          await this.executeScript(config.params, instance.variables);
          break;
        default:
          throw new Error(`不支持的动作: ${config.action}`);
      }

      await this.logWorkflowEvent(
        instance.id,
        'info',
        `服务任务执行成功: ${config.action}`,
        node.id,
      );

      // 继续执行下一个节点
      const dsl = instance.workflow.dsl as WorkflowDSL;
      const outgoingEdges = dsl.edges.filter((e) => e.source === node.id);

      if (outgoingEdges.length > 0) {
        await this.executeNode(instance.id, outgoingEdges[0].target);
      }
    } catch (error) {
      await this.handleServiceTaskError(instance, node, error);
    }
  }

  /**
   * 执行排他网关
   */
  private async executeGateway(
    instance: WorkflowInstance,
    node: WorkflowNode,
    dsl: WorkflowDSL,
  ): Promise<void> {
    const outgoingEdges = dsl.edges.filter((e) => e.source === node.id);

    if (outgoingEdges.length === 0) {
      throw new Error('网关没有出边');
    }

    // 评估条件，找到第一个满足的分支
    for (const edge of outgoingEdges) {
      if (edge.condition) {
        const result = await this.evaluateCondition(edge.condition, instance.variables);
        if (result) {
          await this.logWorkflowEvent(
            instance.id,
            'info',
            `网关选择分支: ${edge.label || edge.id}`,
            node.id,
          );
          await this.executeNode(instance.id, edge.target);
          return;
        }
      }
    }

    // 如果没有满足的条件，使用默认分支
    const defaultEdgeId = (node.props as GatewayConfig)?.defaultEdge;
    const defaultEdge = outgoingEdges.find((e) => e.id === defaultEdgeId);

    if (defaultEdge) {
      await this.logWorkflowEvent(
        instance.id,
        'info',
        '网关选择默认分支',
        node.id,
      );
      await this.executeNode(instance.id, defaultEdge.target);
    } else {
      throw new Error('网关没有满足条件的分支，也没有默认分支');
    }
  }

  /**
   * 执行并行网关（分裂）
   */
  private async executeParallelGateway(
    instance: WorkflowInstance,
    node: WorkflowNode,
    dsl: WorkflowDSL,
  ): Promise<void> {
    const outgoingEdges = dsl.edges.filter((e) => e.source === node.id);

    if (outgoingEdges.length === 0) {
      throw new Error('并行网关没有出边');
    }

    // 获取当前令牌
    const currentToken = await this.prisma.workflowToken.findFirst({
      where: {
        instanceId: instance.id,
        nodeId: node.id,
        status: 'active',
      },
    });

    // 为每个分支创建子令牌
    for (const edge of outgoingEdges) {
      await this.createToken(instance.id, edge.target, currentToken?.id);
    }

    // 完成当前令牌
    if (currentToken) {
      await this.completeToken(instance.id, node.id);
    }

    await this.logWorkflowEvent(
      instance.id,
      'info',
      `并行网关分裂为 ${outgoingEdges.length} 个分支`,
      node.id,
    );

    // 并行执行所有分支
    await Promise.all(
      outgoingEdges.map((edge) => this.executeNode(instance.id, edge.target)),
    );
  }

  /**
   * 条件求值
   */
  private async evaluateCondition(
    condition: string,
    variables: Record<string, any>,
  ): Promise<boolean> {
    const conditionEvaluator = new ConditionEvaluatorService();
    return conditionEvaluator.evaluate(condition, variables);
  }

  /**
   * 解析审批人
   */
  private resolveAssignee(
    assigneeTemplate: string,
    variables: Record<string, any>,
  ): string {
    const handlebars = require('handlebars');
    const template = handlebars.compile(assigneeTemplate);
    return template(variables);
  }

  /**
   * 解析超时时间（ISO 8601 Duration）
   */
  private parseDueDate(duration: string): Date {
    // 简单实现，支持 P1D (1天), PT1H (1小时) 等
    const match = duration.match(/P(?:(\d+)D)?T?(?:(\d+)H)?/);
    if (!match) {
      throw new Error(`无效的时间格式: ${duration}`);
    }

    const days = parseInt(match[1] || '0', 10);
    const hours = parseInt(match[2] || '0', 10);

    const dueDate = new Date();
    dueDate.setDate(dueDate.getDate() + days);
    dueDate.setHours(dueDate.getHours() + hours);

    return dueDate;
  }

  /**
   * 创建令牌
   */
  private async createToken(
    instanceId: string,
    nodeId: string,
    parentTokenId?: string,
  ): Promise<void> {
    await this.prisma.workflowToken.create({
      data: {
        instanceId,
        nodeId,
        parentTokenId,
        status: 'active',
      },
    });
  }

  /**
   * 完成令牌
   */
  private async completeToken(instanceId: string, nodeId: string): Promise<void> {
    await this.prisma.workflowToken.updateMany({
      where: {
        instanceId,
        nodeId,
        status: 'active',
      },
      data: {
        status: 'completed',
        completedAt: new Date(),
      },
    });
  }

  /**
   * 记录工作流日志
   */
  private async logWorkflowEvent(
    instanceId: string,
    level: string,
    message: string,
    nodeId?: string,
    taskId?: string,
  ): Promise<void> {
    await this.prisma.workflowLog.create({
      data: {
        instanceId,
        level,
        message,
        nodeId,
        taskId,
        metadata: {},
      },
    });
  }

  /**
   * 验证工作流 DSL
   */
  private validateWorkflowDSL(dsl: WorkflowDSL): void {
    // 检查开始节点
    const startNodes = dsl.nodes.filter((n) => n.type === 'StartEvent');
    if (startNodes.length !== 1) {
      throw new Error('工作流必须有且仅有一个开始节点');
    }

    // 检查结束节点
    const endNodes = dsl.nodes.filter((n) => n.type === 'EndEvent');
    if (endNodes.length === 0) {
      throw new Error('工作流至少需要一个结束节点');
    }

    // 更多验证逻辑...
  }

  // 辅助方法
  private async sendEmail(params: any, variables: any): Promise<void> {
    // 发送邮件实现
  }

  private async callApi(params: any, variables: any): Promise<void> {
    // 调用 API 实现
  }

  private async executeScript(params: any, variables: any): Promise<void> {
    // 执行脚本实现
  }

  private async handleServiceTaskError(
    instance: WorkflowInstance,
    node: WorkflowNode,
    error: any,
  ): Promise<void> {
    await this.logWorkflowEvent(
      instance.id,
      'error',
      `服务任务执行失败: ${error.message}`,
      node.id,
    );

    await this.prisma.workflowInstance.update({
      where: { id: instance.id },
      data: {
        status: 'error',
        errorMessage: error.message,
      },
    });

    this.eventBus.emit('workflow.error', {
      instanceId: instance.id,
      error: error.message,
    });
  }
}
```

---

## 4. 条件求值器

```typescript
@Injectable()
export class ConditionEvaluatorService {
  /**
   * 评估条件表达式
   * 支持模板语法: {{ level === '一级动火' }}
   */
  evaluate(condition: string, variables: Record<string, any>): boolean {
    try {
      // 移除模板标记
      const expression = condition.replace(/\{\{|\}\}/g, '').trim();

      // 使用 Handlebars 解析变量
      const handlebars = require('handlebars');
      handlebars.registerHelper('eq', (a, b) => a === b);
      handlebars.registerHelper('ne', (a, b) => a !== b);
      handlebars.registerHelper('gt', (a, b) => a > b);
      handlebars.registerHelper('lt', (a, b) => a < b);
      handlebars.registerHelper('gte', (a, b) => a >= b);
      handlebars.registerHelper('lte', (a, b) => a <= b);

      // 安全求值（使用沙箱）
      const context = this.createSafeContext(variables);
      const result = this.evaluateExpression(expression, context);

      return Boolean(result);
    } catch (error) {
      console.error('条件求值失败:', error);
      return false;
    }
  }

  /**
   * 创建安全的求值上下文
   */
  private createSafeContext(variables: Record<string, any>): any {
    // 创建一个沙箱环境，防止访问不安全的对象
    return new Proxy(variables, {
      get(target, prop) {
        // 禁止访问原型链
        if (prop === '__proto__' || prop === 'constructor') {
          return undefined;
        }
        return target[prop];
      },
    });
  }

  /**
   * 安全求值表达式
   */
  private evaluateExpression(expression: string, context: any): any {
    // 使用 Function 构造函数创建沙箱
    // 注意：生产环境建议使用 vm2 或 isolated-vm
    const func = new Function(
      'context',
      `with(context) { return (${expression}); }`,
    );
    return func(context);
  }
}
```

---

## 5. API 设计

### 5.1 工作流实例管理

```typescript
// POST /api/workflows/:id/start - 启动工作流
{
  variables: {
    level: '一级动火',
    applicant: 'user123',
    department: '技术部'
  }
}

// Response
{
  success: true,
  data: {
    id: 'instance_123',
    workflowId: 'workflow_456',
    status: 'running',
    currentNodeIds: ['userTask-1'],
    createdAt: '2025-12-28T10:00:00Z'
  }
}

// GET /api/workflows/instances - 获取实例列表
// Query: status, initiator, pageSize, pageNumber

// GET /api/workflows/instances/:id - 获取实例详情
// Response 包含: instance, tasks, logs, tokens

// POST /api/workflows/instances/:id/cancel - 取消工作流
```

### 5.2 任务管理

```typescript
// GET /api/tasks/my - 获取我的待办
// Query: status, pageSize, pageNumber

// Response
{
  success: true,
  data: {
    items: [
      {
        id: 'task_123',
        instanceId: 'instance_456',
        nodeName: '部门经理审批',
        assignee: 'user123',
        status: 'pending',
        createdAt: '2025-12-28T10:00:00Z',
        dueDate: '2025-12-29T10:00:00Z',
        workflow: {
          name: '动火作业审批流程'
        }
      }
    ],
    total: 5,
    page: 1,
    pageSize: 10
  }
}

// GET /api/tasks/:id - 获取任务详情
// Response 包含: task, instance, workflow, formSchema

// POST /api/tasks/:id/complete - 完成任务
{
  formData: {
    approvalResult: 'approved',
    comment: '同意申请'
  },
  completedBy: 'user123'
}

// POST /api/tasks/:id/reject - 拒绝任务
{
  comment: '不符合要求',
  completedBy: 'user123'
}

// POST /api/tasks/:id/delegate - 委托任务
{
  delegateTo: 'user456',
  comment: '委托给XXX处理'
}
```

---

## 6. 事件系统

```typescript
// 工作流事件
export enum WorkflowEventType {
  STARTED = 'workflow.started',
  COMPLETED = 'workflow.completed',
  ERROR = 'workflow.error',
  CANCELLED = 'workflow.cancelled',
  NODE_EXECUTED = 'workflow.node.executed',
}

// 任务事件
export enum TaskEventType {
  CREATED = 'task.created',
  COMPLETED = 'task.completed',
  REJECTED = 'task.rejected',
  DELEGATED = 'task.delegated',
  OVERDUE = 'task.overdue',
}

// 事件监听器示例
@Injectable()
export class WorkflowEventListener {
  @OnEvent('workflow.started')
  async handleWorkflowStarted(payload: { instanceId: string }) {
    // 发送通知、记录日志等
  }

  @OnEvent('task.created')
  async handleTaskCreated(payload: { taskId: string }) {
    // 发送待办通知
  }

  @OnEvent('task.overdue')
  async handleTaskOverdue(payload: { taskId: string }) {
    // 发送超时提醒
  }
}
```

---

## 7. 定时任务（超时处理）

```typescript
@Injectable()
export class TaskTimeoutService {
  constructor(
    private prisma: PrismaService,
    private eventBus: EventEmitter2,
  ) {}

  /**
   * 定时检查超时任务（每分钟执行）
   */
  @Cron('0 * * * * *')
  async checkOverdueTasks(): Promise<void> {
    const now = new Date();

    // 查询超时的任务
    const overdueTasks = await this.prisma.taskInstance.findMany({
      where: {
        status: 'pending',
        dueDate: {
          lte: now,
        },
      },
    });

    for (const task of overdueTasks) {
      // 发送超时事件
      this.eventBus.emit('task.overdue', { taskId: task.id });

      // 可以配置超时后的自动处理策略
      // 例如：自动拒绝、自动升级等
    }
  }
}
```

---

## 8. 测试策略

### 8.1 单元测试

```typescript
describe('WorkflowExecutorService', () => {
  it('应该成功启动工作流', async () => {
    // 测试启动逻辑
  });

  it('应该正确执行用户任务节点', async () => {
    // 测试用户任务创建
  });

  it('应该正确评估网关条件', async () => {
    // 测试条件分支
  });

  it('应该支持并行网关', async () => {
    // 测试并行执行
  });
});

describe('ConditionEvaluatorService', () => {
  it('应该正确评估简单条件', () => {
    const result = evaluator.evaluate(
      "{{ level === '一级动火' }}",
      { level: '一级动火' }
    );
    expect(result).toBe(true);
  });

  it('应该支持复杂逻辑表达式', () => {
    const result = evaluator.evaluate(
      "{{ level === '一级动火' && department === '技术部' }}",
      { level: '一级动火', department: '技术部' }
    );
    expect(result).toBe(true);
  });
});
```

### 8.2 集成测试

```typescript
describe('Workflow End-to-End', () => {
  it('应该完整执行动火作业审批流程', async () => {
    // 1. 启动工作流
    const instance = await workflowExecutor.startWorkflow(
      workflowId,
      { level: '一级动火', applicant: 'user123' },
      'user123',
      'tenant_1'
    );

    // 2. 获取待办任务
    const tasks = await taskManager.getMyTasks('manager_1');
    expect(tasks.length).toBe(1);

    // 3. 完成任务
    await workflowExecutor.completeUserTask(
      tasks[0].id,
      { approvalResult: 'approved' },
      'manager_1'
    );

    // 4. 验证工作流状态
    const updatedInstance = await prisma.workflowInstance.findUnique({
      where: { id: instance.id },
    });
    expect(updatedInstance.status).toBe('completed');
  });
});
```

---

## 9. 性能优化

### 9.1 任务队列

```typescript
// 使用 Bull 处理异步任务
@Processor('workflow-execution')
export class WorkflowExecutionProcessor {
  @Process('execute-node')
  async handleNodeExecution(job: Job) {
    const { instanceId, nodeId } = job.data;
    await this.workflowExecutor.executeNode(instanceId, nodeId);
  }

  @Process('complete-task')
  async handleTaskCompletion(job: Job) {
    const { taskId, formData, completedBy } = job.data;
    await this.workflowExecutor.completeUserTask(taskId, formData, completedBy);
  }
}
```

### 9.2 缓存策略

```typescript
// 缓存工作流定义
@Injectable()
export class WorkflowCacheService {
  constructor(private redis: Redis) {}

  async getWorkflowDSL(workflowId: string): Promise<WorkflowDSL> {
    const cached = await this.redis.get(`workflow:${workflowId}`);
    if (cached) {
      return JSON.parse(cached);
    }

    const workflow = await this.prisma.workflow.findUnique({
      where: { id: workflowId },
    });

    if (workflow) {
      await this.redis.setex(
        `workflow:${workflowId}`,
        3600, // 1小时
        JSON.stringify(workflow.dsl)
      );
    }

    return workflow.dsl as WorkflowDSL;
  }
}
```

---

## 10. 监控与观测

```typescript
// 工作流指标收集
@Injectable()
export class WorkflowMetricsService {
  // 记录执行时长
  recordExecutionTime(workflowId: string, duration: number): void {
    // 发送到 Prometheus
  }

  // 记录任务完成率
  recordTaskCompletionRate(workflowId: string, rate: number): void {
    // ...
  }

  // 记录错误率
  recordErrorRate(workflowId: string, errorCount: number): void {
    // ...
  }
}

// 健康检查
@Controller('health')
export class HealthController {
  @Get('workflow-engine')
  async checkWorkflowEngine() {
    // 检查数据库连接
    // 检查 Redis 连接
    // 检查待处理任务队列长度
    return {
      status: 'healthy',
      details: {
        database: 'ok',
        redis: 'ok',
        pendingTasks: 5,
      },
    };
  }
}
```

---

## 11. 部署建议

### 11.1 环境变量

```env
# 工作流引擎配置
WORKFLOW_MAX_EXECUTION_TIME=3600000  # 1小时
WORKFLOW_MAX_PARALLEL_TASKS=10
WORKFLOW_RETRY_ATTEMPTS=3

# Redis 配置（用于任务队列）
REDIS_HOST=localhost
REDIS_PORT=6379

# 日志级别
LOG_LEVEL=info
```

### 11.2 水平扩展

- 使用任务队列实现无状态服务
- 多个 worker 实例处理任务
- Redis 作为分布式锁，防止重复执行

---

## 12. 后续优化方向

1. **子流程支持** - 支持调用其他工作流作为子流程
2. **流程版本管理** - 支持版本升级和实例迁移
3. **错误重试机制** - 服务任务失败自动重试
4. **流程监控看板** - 实时监控流程执行状态
5. **流程分析报表** - 统计平均处理时间、瓶颈节点
6. **动态表单生成** - 根据节点配置自动生成审批表单
7. **消息通知集成** - 支持邮件、短信、企业微信通知
8. **流程模板市场** - 提供常用流程模板

---

## 13. 开发计划

### Week 1: 核心引擎
- Day 1-2: Prisma Schema 扩展 + 基础服务搭建
- Day 3-4: 工作流执行器核心逻辑
- Day 5: 条件求值器 + 表达式解析

### Week 2: 任务管理
- Day 1-2: 任务管理服务 + API
- Day 3: 待办中心前端 UI
- Day 4-5: 任务审批界面 + 表单渲染

### Week 3: 高级功能
- Day 1: 并行网关支持
- Day 2: 事件系统 + 通知
- Day 3: 超时处理 + 定时任务
- Day 4-5: 测试 + 优化

### Week 4: 集成与测试
- Day 1-2: 端到端测试
- Day 3: 性能测试 + 优化
- Day 4: 监控 + 日志
- Day 5: 文档 + 部署

---

## 14. 参考资料

- **Camunda BPMN**: https://camunda.com/
- **Activiti**: https://www.activiti.org/
- **BPMN 2.0 规范**: https://www.omg.org/spec/BPMN/2.0/
- **Bull 任务队列**: https://docs.bullmq.io/
- **Handlebars 模板**: https://handlebarsjs.com/
